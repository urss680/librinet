```html
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Editor de Audio</title>
  <style>
    body{font-family:Arial,Helvetica,sans-serif;background:#111;color:#eee;display:flex;flex-direction:column;align-items:center;padding:20px}
    canvas{background:#000;border:1px solid #555;margin:10px 0}
    button{margin:5px;padding:8px 14px;background:#28a745;color:#fff;border:none;border-radius:4px;cursor:pointer}
    button:disabled{background:#444;cursor:not-allowed}
    input[type=file]{margin:5px}
  </style>
</head>
<body>

  <h1>Editor de Audio</h1>

  <input type="file" id="fileInput" accept="audio/*">
  <button id="recBtn">Grabar</button>
  <button id="stopBtn" disabled>Detener</button>
  <button id="playBtn" disabled>Reproducir</button>
  <button id="cutBtn" disabled>Cortar selecci√≥n</button>
  <button id="downloadBtn" disabled>Descargar WAV</button>
  <button id="saveProjectBtn" disabled>Descargar .au (proyecto)</button>

  <canvas id="canvas" width="800" height="200"></canvas>

  <script>
    const canvas=document.getElementById('canvas'),ctx=canvas.getContext('2d');
    let audioCtx,source,buffer,recorder,recordedChunks=[],selection={start:0,end:0};
    let mouseDown=false,mouseX=0;

    document.getElementById('fileInput').addEventListener('change',e=>{
      const file=e.target.files[0];
      if(!file)return;
      const reader=new FileReader();
      reader.onload=ev=>{
        audioCtx=new (window.AudioContext||window.webkitAudioContext)();
        audioCtx.decodeAudioData(ev.target.result,decoded=>{
          buffer=decoded;
          drawWaveform();
          enableButtons();
        });
      };
      reader.readAsArrayBuffer(file);
    });

    document.getElementById('recBtn').onclick=()=>{
      navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
        recordedChunks=[];
        recorder=new MediaRecorder(stream);
        recorder.ondataavailable=e=>recordedChunks.push(e.data);
        recorder.onstop=()=>{
          const blob=new Blob(recordedChunks,{type:'audio/wav'});
          const reader=new FileReader();
          reader.onloadend=()=>{
            audioCtx=new (window.AudioContext||window.webkitAudioContext)();
            audioCtx.decodeAudioData(reader.result,decoded=>{
              buffer=decoded;
              drawWaveform();
              enableButtons();
            });
          };
          reader.readAsArrayBuffer(blob);
        };
        recorder.start();
        document.getElementById('recBtn').disabled=true;
        document.getElementById('stopBtn').disabled=false;
      });
    };

    document.getElementById('stopBtn').onclick=()=>{
      recorder.stop();
      recorder.stream.getTracks().forEach(t=>t.stop());
      document.getElementById('recBtn').disabled=false;
      document.getElementById('stopBtn').disabled=true;
    };

    document.getElementById('playBtn').onclick=()=>{
      if(source)source.stop();
      source=audioCtx.createBufferSource();
      source.buffer=buffer;
      source.connect(audioCtx.destination);
      source.start();
    };

    canvas.addEventListener('mousedown',e=>{
      mouseDown=true;
      mouseX=e.offsetX;
      selection.start=mouseX/canvas.width;
    });
    canvas.addEventListener('mouseup',e=>{
      mouseDown=false;
      selection.end=e.offsetX/canvas.width;
      drawWaveform();
    });

    document.getElementById('cutBtn').onclick=()=>{
      if(!buffer)return;
      const start=Math.floor(selection.start*buffer.length);
      const end=Math.floor(selection.end*buffer.length);
      const newLength=end-start;
      const newBuffer=audioCtx.createBuffer(buffer.numberOfChannels,newLength,buffer.sampleRate);
      for(let c=0;c<buffer.numberOfChannels;c++){
        const oldData=buffer.getChannelData(c);
        const newData=newBuffer.getChannelData(c);
        for(let i=0;i<newLength;i++)newData[i]=oldData[start+i];
      }
      buffer=newBuffer;
      drawWaveform();
    });

    document.getElementById('downloadBtn').onclick=()=>{
      const wav=toWav(buffer);
      const blob=new Blob([wav],{type:'audio/wav'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');a.href=url;a.download='editado.wav';a.click();
    };

    document.getElementById('saveProjectBtn').onclick=()=>{
      const project={
        sampleRate:buffer.sampleRate,
        length:buffer.length,
        numberOfChannels:buffer.numberOfChannels,
        channels:[]
      };
      for(let c=0;c<buffer.numberOfChannels;c++){
        project.channels.push(Array.from(buffer.getChannelData(c)));
      }
      const blob=new Blob([JSON.stringify(project)],{type:'application/json'});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');a.href=url;a.download='proyecto.au';a.click();
    };

    function drawWaveform(){
      if(!buffer)return;
      const width=canvas.width,height=canvas.height,data=buffer.getChannelData(0);
      ctx.fillStyle='#000';ctx.fillRect(0,0,width,height);
      ctx.strokeStyle='#0f0';ctx.beginPath();
      const step=buffer.length/width;
      for(let i=0;i<width;i++){
        let min=1,max=-1;
        for(let j=0;j<step;j++){
          const d=data[Math.floor(i*step+j)];
          if(d<min)min=d;
          if(d>max)max=d;
        }
        ctx.moveTo(i,(1+min)*height/2);
        ctx.lineTo(i,(1+max)*height/2);
      }
      ctx.stroke();
      if(selection.start!==selection.end){
        ctx.fillStyle='rgba(255,255,255,0.3)';
        ctx.fillRect(selection.start*width,0,(selection.end-selection.start)*width,height);
      }
    }

    function enableButtons(){
      document.getElementById('playBtn').disabled=false;
      document.getElementById('cutBtn').disabled=false;
      document.getElementById('downloadBtn').disabled=false;
      document.getElementById('saveProjectBtn').disabled=false;
    }

    function toWav(buffer){
      const length=buffer.length*buffer.numberOfChannels*2+44;
      const arrayBuffer=new ArrayBuffer(length);
      const view=new DataView(arrayBuffer);
      const channels=[];
      let offset=0;
      const writeString=(str)=>{
        for(let i=0;i<str.length;i++)view.setUint8(offset++,str.charCodeAt(i));
      };
      const writeUint32=(v)=>{view.setUint32(offset,v,true);offset+=4;};
      const writeUint16=(v)=>{view.setUint16(offset,v,true);offset+=2;};
      writeString('RIFF');writeUint32(length-8);
      writeString('WAVE');writeString('fmt ');
      writeUint32(16);writeUint16(1);writeUint16(buffer.numberOfChannels);
      writeUint32(buffer.sampleRate);writeUint32(buffer.sampleRate*buffer.numberOfChannels*2);
      writeUint16(buffer.numberOfChannels*2);writeUint16(16);
      writeString('data');writeUint32(buffer.length*buffer.numberOfChannels*2);
      for(let c=0;c<buffer.numberOfChannels;c++)channels.push(buffer.getChannelData(c));
      for(let i=0;i<buffer.length;i++){
        for(let c=0;c<buffer.numberOfChannels;c++){
          let sample=Math.max(-1,Math.min(1,channels[c][i]));
          sample=sample<0?sample*32768:sample*32767;
          view.setInt16(offset,sample,true);offset+=2;
        }
      }
      return arrayBuffer;
    }
  </script>

</body>
</html>
```