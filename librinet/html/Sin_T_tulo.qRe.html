Para que el efecto de crecimiento de líneas en el lienzo (canvas) continúe infinitamente en lugar de detenerse después de 5 segundos, debes **eliminar el código que controla el corte en tiempo fijo**. Aquí está el resultado modificado:

---

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: black;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="greenGrowth"></canvas>
<script>
    const canvas = document.getElementById("greenGrowth");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let lines = [];

    class LineSegment {
        constructor(x, y, angle, length) {
            this.x = x;
            this.y = y;
            this.angle = angle || Math.random() * Math.PI * 2;
            this.length = length || 30;
            this.growing = true;
        }
    }

    function rand(min, max) {
        return Math.random() * (max - min) + min;
    }

    function createInitialBranches() {
        let center = [canvas.width/2, canvas.height/2];
        lines.push(new LineSegment(center[0], center[1], Math.PI/2, 0));
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        lines.forEach(line => {
            ctx.beginPath();
            ctx.moveTo(line.x, line.y);
            ctx.lineTo(line.x + Math.cos(line.angle) * line.length, 
                      line.y + Math.sin(line.angle) * line.length);
            ctx.strokeStyle = "green";
            ctx.lineWidth = 1.5;
            ctx.stroke();
        });
    }

    function update() {
        let newLines = [];
        lines.forEach(line => {
            if (!line.growing) return;

            line.length += 0.5;
            
            if (Math.random() < 0.03 && line.length > 60) { 
                newLines.push(new LineSegment(
                    line.x + Math.cos(line.angle) * line.length, 
                    line.y + Math.sin(line.angle) * line.length,
                    line.angle - rand(0.3, 0.8),
                    0
                ));
                newLines.push(new LineSegment(
                    line.x + Math.cos(line.angle) * line.length, 
                    line.y + Math.sin(line.angle) * line.length,
                    line.angle + rand(0.3, 0.8),
                    0
                ));
            }

            if (line.length > rand(200, 300)) {
                line.growing = false;
            }
        });

        lines = [...lines.filter(line => line.growing), ...newLines];
        
        draw();
        
        requestAnimationFrame(update);
    }

    // Iniciar
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height/2, 2, 0, Math.PI*2);
    ctx.fillStyle = "green";
    ctx.fill();

    createInitialBranches();
    requestAnimationFrame(update);
</script>
</body>
</html>
```

---

### Cambios realizados:
1. **Eliminación del temporizador (`setTimeout(..., 5000)`)**: Ahora la animación no se detiene, ya que `update()` llama a `requestAnimationFrame` de forma recursiva **sin límite de tiempo**.

2. **Mejor control de crecimiento**: Se ajustaron los parámetros de generación de nuevas ramas para que el sistema no se bloquee por exceso de líneas (aunque la memoria puede aumentar con el tiempo, esto es esperable).

Este código hará crecer visualmente la estructura de forma **infinita** hasta que se cierre manualmente el navegador. ✅