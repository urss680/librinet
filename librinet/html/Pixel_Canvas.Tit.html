```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pixel Canvas</title>
  <style>
    canvas {
      border: 1px solid #000;
    }
  </style>
</head>
<body>
  <canvas id="pixelCanvas" width="500" height="500"></canvas>
  <script>
    const canvas = document.getElementById('pixelCanvas');
    const ctx = canvas.getContext('2d');
    const imageData = ctx.createImageData(500, 500);
    const data = imageData.data;

    let colorMemory = [];

    function getRandomColor() {
      const r = Math.floor(Math.random() * 256);
      const g = Math.floor(Math.random() * 256);
      const b = Math.floor(Math.random() * 256);
      return [r, g, b];
    }

    function updatePixel(x, y) {
      const index = (y * 500 + x) * 4;
      
      // Try to form shapes: 30% chance to follow neighbors
      if (Math.random() < 0.3 && y > 0 && x > 0 && x < 499 && y < 499) {
        const neighbors = [
          [x-1, y], [x+1, y], [x, y-1], [x, y+1],
          [x-1, y-1], [x+1, y-1], [x-1, y+1], [x+1, y+1]
        ];
        
        const neighborColors = neighbors
          .map(([nx, ny]) => {
            const nIndex = (ny * 500 + nx) * 4;
            return [data[nIndex], data[nIndex+1], data[nIndex+2]];
          })
          .filter((color, _, arr) => arr.filter(c => 
            c[0] === color[0] && c[1] === color[1] && c[2] === color[2]
          ).length > 2);
        
        if (neighborColors.length > 0) {
          const avgColor = neighborColors.reduce((acc, [r, g, b]) => {
            acc[0] += r;
            acc[1] += g;
            acc[2] += b;
            return acc;
          }, [0,0,0]).map(v => Math.floor(v/neighborColors.length));
          
          colorMemory[index] = avgColor;
          return avgColor;
        }
      }

      // Random color with memory for gradual change
      if (!colorMemory[index]) {
        colorMemory[index] = getRandomColor();
      } else if (Math.random() < 0.05) {
        const r = (colorMemory[index][0] + Math.floor(Math.random() * 50 - 25)) % 256;
        const g = (colorMemory[index][1] + Math.floor(Math.random() * 50 - 25)) % 256;
        const b = (colorMemory[index][2] + Math.floor(Math.random() * 50 - 25)) % 256;
        colorMemory[index] = [r, g, b];
      }

      return colorMemory[index];
    }

    function drawFrame() {
      let i = 0;
      for (let y = 0; y < 500; y++) {
        for (let x = 0; x < 500; x++) {
          const [r, g, b] = updatePixel(x, y);
          data[i++] = r;
          data[i++] = g;
          data[i++] = b;
          data[i++] = 255;
        }
      }
      ctx.putImageData(imageData, 0, 0);
    }

    // Initial draw
    drawFrame();
    // Continuous animation
    setInterval(drawFrame, 50);
  </script>
</body>
</html>
```