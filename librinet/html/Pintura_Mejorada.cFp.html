```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Pintura Mejorada</title>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #f0f0f0;
            font-family: sans-serif;
            padding-bottom: 20px;
        }
        canvas {
            border: 2px solid #333;
            cursor: crosshair;
            background: white;
            position: relative;
            touch-action: none;
        }
        .controls {
            margin: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            background: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,.15);
            max-width: 90vw;
        }
        .controls input[type=color],
        .controls input[type=range],
        .controls button,
        .controls input[type=number],
        .controls input[type=text] {
            vertical-align: middle;
        }
        .controls label {
            font-size: 14px;
        }
        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 6px;
            border-radius: 4px;
            transition: background .2s;
            font-size: 24px;
        }
        .icon-btn:hover {
            background: #e0e0e0;
        }
        .icon-btn.active {
            background: #ccc;
        }
        #coordDisplay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
        }
        #textControls {
            display: none;
            gap: 8px;
            align-items: center;
        }
        #shapeControls {
            display: none;
            flex-direction: column;
            gap: 4px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 6px;
            padding: 6px;
            background: #fafafa;
        }
        #shapeControls button {
            width: 100%;
            text-align: left;
            margin: 2px 0;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            transition: background .2s;
        }
        #shapeControls button:hover {
            background: #e0e0e0;
        }
        #downloadBtn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        #downloadBtn:hover {
            background: #45a049;
        }
        #autofixBtn {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        #autofixBtn:hover {
            background: #0b7dda;
        }
    </style>
</head>
<body>
    <div class="controls">
        <label>Color: <input type="color" id="colorPicker" value="#000000"></label>
        <label>Grosor: <input type="range" id="brushSize" min="1" max="50" value="5"></label>
        <span id="sizeLabel">5</span>

        <button id="pencilBtn" class="icon-btn active" title="L√°piz">‚úèÔ∏è</button>
        <button id="eraserBtn" class="icon-btn" title="Borrador">üßπ</button>
        <button id="sprayBtn" class="icon-btn" title="Grafiti">üé®</button>
        <button id="penBtn" class="icon-btn" title="Pluma">üñäÔ∏è</button>
        <button id="brushBtn" class="icon-btn" title="Pincel">üñåÔ∏è</button>
        <button id="fillBtn" class="icon-btn" title="Rellenar">ü™£</button>
        <button id="textBtn" class="icon-btn" title="Texto">üìù</button>
        <button id="shapeBtn" class="icon-btn" title="Formas">‚≠ï</button>
        <button id="clearBtn" class="icon-btn" title="Limpiar">üóëÔ∏è</button>
        <button id="downloadBtn" title="Descargar">üíæ Descargar</button>
        <button id="autofixBtn" title="Auto-mejorar">‚ú® Auto-mejorar</button>
        <label><input type="checkbox" id="showCoords" checked> Coordenadas</label>

        <div id="textControls">
            <label>Tama√±o: <input type="number" id="textSize" value="20" min="8" max="200"></label>
            <input type="text" id="textInput" placeholder="Escribe texto aqu√≠">
            <button id="addTextBtn">A√±adir</button>
        </div>

        <div id="shapeControls">
            <button data-shape="rect">Rect√°ngulo</button>
            <button data-shape="filledRect">Rect√°ngulo Relleno</button>
            <button data-shape="circle">C√≠rculo</button>
            <button data-shape="filledCircle">C√≠rculo Relleno</button>
            <button data-shape="line">L√≠nea</button>
            <button data-shape="triangle">Tri√°ngulo</button>
            <button data-shape="filledTriangle">Tri√°ngulo Relleno</button>
            <button data-shape="star">Estrella</button>
            <button data-shape="filledStar">Estrella Rellena</button>
            <button data-shape="heart">Coraz√≥n</button>
            <button data-shape="filledHeart">Coraz√≥n Relleno</button>
            <button data-shape="hexagon">Hex√°gono</button>
            <button data-shape="filledHexagon">Hex√°gono Relleno</button>
            <button data-shape="pentagon">Pent√°gono</button>
            <button data-shape="filledPentagon">Pent√°gono Relleno</button>
            <button data-shape="ellipse">Elipse</button>
            <button data-shape="filledEllipse">Elipse Rellena</button>
            <button data-shape="arrow">Flecha</button>
            <button data-shape="diamond">Diamante</button>
            <button data-shape="filledDiamond">Diamante Relleno</button>
        </div>
    </div>

    <div style="position: relative;">
        <canvas id="canvas" width="800" height="600"></canvas>
        <div id="coordDisplay">X: 0, Y: 0</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');
        const sizeLabel = document.getElementById('sizeLabel');
        const coordDisplay = document.getElementById('coordDisplay');
        const showCoords = document.getElementById('showCoords');

        const pencilBtn = document.getElementById('pencilBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const sprayBtn = document.getElementById('sprayBtn');
        const penBtn = document.getElementById('penBtn');
        const brushBtn = document.getElementById('brushBtn');
        const fillBtn = document.getElementById('fillBtn');
        const textBtn = document.getElementById('textBtn');
        const shapeBtn = document.getElementById('shapeBtn');
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const autofixBtn = document.getElementById('autofixBtn');

        const textControls = document.getElementById('textControls');
        const textSize = document.getElementById('textSize');
        const textInput = document.getElementById('textInput');
        const addTextBtn = document.getElementById('addTextBtn');

        const shapeControls = document.getElementById('shapeControls');
        let drawing = false;
        let filling = false;
        let texting = false;
        let spraying = false;
        let penMode = false;
        let brushMode = false;
        let shaping = false;
        let shapeType = '';
        let erasing = false;
        let startX, startY;
        let textX = 0;
        let textY = 0;

        function setActiveMode(mode) {
            [pencilBtn, eraserBtn, sprayBtn, penBtn, brushBtn, fillBtn, textBtn, shapeBtn].forEach(btn => btn.classList.remove('active'));
            if (mode === 'pencil') {
                pencilBtn.classList.add('active');
                erasing = false; filling = false; texting = false; spraying = false; penMode = false; brushMode = false; shaping = false;
                canvas.style.cursor = 'crosshair';
                textControls.style.display = 'none';
                shapeControls.style.display = 'none';
            } else if (mode === 'eraser') {
                eraserBtn.classList.add('active');
                erasing = true; filling = false; texting = false; spraying = false; penMode = false; brushMode = false; shaping = false;
                canvas.style.cursor = 'crosshair';
                textControls.style.display = 'none';
                shapeControls.style.display = 'none';
            } else if (mode === 'spray') {
                sprayBtn.classList.add('active');
                spraying = true; erasing = false; filling = false; texting = false; penMode = false; brushMode = false; shaping = false;
                canvas.style.cursor = 'crosshair';
                textControls.style.display = 'none';
                shapeControls.style.display = 'none';
            } else if (mode === 'pen') {
                penBtn.classList.add('active');
                penMode = true; spraying = false; erasing = false; filling = false; texting = false; brushMode = false; shaping = false;
                canvas.style.cursor = 'crosshair';
                textControls.style.display = 'none';
                shapeControls.style.display = 'none';
            } else if (mode === 'brush') {
                brushBtn.classList.add('active');
                brushMode = true; penMode = false; spraying = false; erasing = false; filling = false; texting = false; shaping = false;
                canvas.style.cursor = 'crosshair';
                textControls.style.display = 'none';
                shapeControls.style.display = 'none';
            } else if (mode === 'fill') {
                fillBtn.classList.add('active');
                filling = true; erasing = false; texting = false; spraying = false; penMode = false; brushMode = false; shaping = false;
                canvas.style.cursor = 'pointer';
                textControls.style.display = 'none';
                shapeControls.style.display = 'none';
            } else if (mode === 'text') {
                textBtn.classList.add('active');
                texting = true; filling = false; erasing = false; spraying = false; penMode = false; brushMode = false; shaping = false;
                canvas.style.cursor = 'text';
                textControls.style.display = 'flex';
                shapeControls.style.display = 'none';
            } else if (mode === 'shape') {
                shapeBtn.classList.add('active');
                shaping = true; texting = false; filling = false; erasing = false; spraying = false; penMode = false; brushMode = false;
                canvas.style.cursor = 'crosshair';
                textControls.style.display = 'none';
                shapeControls.style.display = 'flex';
            }
        }

        pencilBtn.addEventListener('click', () => setActiveMode('pencil'));
        eraserBtn.addEventListener('click', () => setActiveMode('eraser'));
        sprayBtn.addEventListener('click', () => setActiveMode('spray'));
        penBtn.addEventListener('click', () => setActiveMode('pen'));
        brushBtn.addEventListener('click', () => setActiveMode('brush'));
        fillBtn.addEventListener('click', () => setActiveMode('fill'));
        textBtn.addEventListener('click', () => setActiveMode('text'));
        shapeBtn.addEventListener('click', () => setActiveMode('shape'));

        brushSize.addEventListener('input', () => {
            sizeLabel.textContent = brushSize.value;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (showCoords.checked) {
                coordDisplay.textContent = `X: ${e.offsetX}, Y: ${e.offsetY}`;
            }
        });

        function getCoords(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }

        canvas.addEventListener('mousedown', (e) => {
            const { x, y } = getCoords(e);
            if (filling) {
                fillArea(x, y);
                return;
            }
            if (texting) {
                textX = x;
                textY = y;
                return;
            }
            if (shaping) {
                startX = x;
                startY = y;
                return;
            }
            drawing = true;
            ctx.beginPath();
            ctx.moveTo(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getCoords(e);
            if (!drawing || filling || texting || shaping) return;
            ctx.strokeStyle = erasing ? '#ffffff' : colorPicker.value;
            ctx.lineWidth = brushSize.value;
            ctx.lineCap = 'round';
            if (spraying) {
                for (let i = 0; i < 20; i++) {
                    const offsetX = (Math.random() - 0.5) * brushSize.value * 2;
                    const offsetY = (Math.random() - 0.5) * brushSize.value * 2;
                    ctx.fillRect(x + offsetX, y + offsetY, 1, 1);
                }
            } else if (penMode) {
                ctx.lineTo(x, y);
                ctx.stroke();
            } else if (brushMode) {
                ctx.lineWidth = brushSize.value * 2;
                ctx.lineTo(x, y);
                ctx.stroke();
            } else {
                ctx.lineTo(x, y);
                ctx.stroke();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const { x, y } = getCoords(e);
            if (shaping && startX !== undefined && startY !== undefined) {
                const endX = x;
                const endY = y;
                ctx.strokeStyle = colorPicker.value;
                ctx.fillStyle = colorPicker.value;
                ctx.lineWidth = brushSize.value;
                ctx.beginPath();
                if (shapeType === 'rect') {
                    ctx.strokeRect(startX, startY, endX - startX, endY - startY);
                } else if (shapeType === 'filledRect') {
                    ctx.fillRect(startX, startY, endX - startX, endY - startY);
                } else if (shapeType === 'circle') {
                    const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (shapeType === 'filledCircle') {
                    const radius = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                    ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (shapeType === 'line') {
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                } else if (shapeType === 'triangle') {
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, startY);
                    ctx.lineTo((startX + endX) / 2, endY);
                    ctx.closePath();
                    ctx.stroke();
                } else if (shapeType === 'filledTriangle') {
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, startY);
                    ctx.lineTo((startX + endX) / 2, endY);
                    ctx.closePath();
                    ctx.fill();
                } else if (shapeType === 'star') {
                    drawStar(ctx, startX, startY, 5, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)), false);
                } else if (shapeType === 'filledStar') {
                    drawStar(ctx, startX, startY, 5, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)), true);
                } else if (shapeType === 'heart') {
                    drawHeart(ctx, startX, startY, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)), false);
                } else if (shapeType === 'filledHeart') {
                    drawHeart(ctx, startX, startY, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)), true);
                } else if (shapeType === 'hexagon') {
                    drawPolygon(ctx, startX, startY, 6, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)), false);
                } else if (shapeType === 'filledHexagon') {
                    drawPolygon(ctx, startX, startY, 6, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)), true);
                } else if (shapeType === 'pentagon') {
                    drawPolygon(ctx, startX, startY, 5, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)), false);
                } else if (shapeType === 'filledPentagon') {
                    drawPolygon(ctx, startX, startY, 5, Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)), true);
                } else if (shapeType === 'ellipse') {
                    ctx.ellipse(startX, startY, Math.abs(endX - startX), Math.abs(endY - startY), 0, 0, 2 * Math.PI);
                    ctx.stroke();
                } else if (shapeType === 'filledEllipse') {
                    ctx.ellipse(startX, startY, Math.abs(endX - startX), Math.abs(endY - startY), 0, 0, 2 * Math.PI);
                    ctx.fill();
                } else if (shapeType === 'arrow') {
                    drawArrow(ctx, startX, startY, endX, endY);
                } else if (shapeType === 'diamond') {
                    drawDiamond(ctx, startX, startY, Math.abs(endX - startX), false);
                } else if (shapeType === 'filledDiamond') {
                    drawDiamond(ctx, startX, startY, Math.abs(endX - startX), true);
                }
            }
            drawing = false;
            startX = undefined;
            startY = undefined;
        });

        canvas.addEventListener('mouseleave', () => {
            drawing = false;
        });

        function fillArea(x, y) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const startPos = (y * canvas.width + x) * 4;
            const targetColor = {
                r: data[startPos],
                g: data[startPos + 1],
                b: data[startPos + 2],
                a: data[startPos + 3]
            };
            const fillColor = hexToRgb(colorPicker.value);

            if (colorsEqual(targetColor, fillColor)) return;

            const stack = [[x, y]];
            const visited = new Uint8Array(canvas.width * canvas.height);

            function getPixel(px, py) {
                return (py * canvas.width + px) * 4;
            }

            function colorsEqual(c1, c2) {
                return c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.a === c2.a;
            }

            function hexToRgb(hex) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return { r, g, b, a: 255 };
            }

            while (stack.length) {
                const [cx, cy] = stack.pop();
                const idx = cy * canvas.width + cx;
                if (visited[idx]) continue;
                visited[idx] = 1;

                const pos = getPixel(cx, cy);
                const current = {
                    r: data[pos],
                    g: data[pos + 1],
                    b: data[pos + 2],
                    a: data[pos + 3]
                };

                if (!colorsEqual(current, targetColor)) continue;

                data[pos] = fillColor.r;
                data[pos + 1] = fillColor.g;
                data[pos + 2] = fillColor.b;
                data[pos + 3] = fillColor.a;

                if (cx > 0) stack.push([cx - 1, cy]);
                if (cx < canvas.width - 1) stack.push([cx + 1, cy]);
                if (cy > 0) stack.push([cx, cy - 1]);
                if (cy < canvas.height - 1) stack.push([cx, cy + 1]);
            }

            ctx.putImageData(imageData, 0, 0);
        }

        function drawStar(ctx, cx, cy, spikes, outerRadius, filled) {
            const innerRadius = outerRadius / 2;
            const step = Math.PI / spikes;
            let rot = -Math.PI / 2;
            ctx.beginPath();
            for (let i = 0; i < spikes * 2; i++) {
                const radius = i % 2 === 0 ? outerRadius : innerRadius;
                const x = cx + Math.cos(rot) * radius;
                const y = cy + Math.sin(rot) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                rot += step;
            }
            ctx.closePath();
            if (filled) ctx.fill();
            else ctx.stroke();
        }

        function drawHeart(ctx, cx, cy, size, filled) {
            ctx.beginPath();
            const s = size / 4;
            ctx.moveTo(cx, cy + s * 3);
            ctx.bezierCurveTo(cx, cy + s * 3, cx - s * 2, cy, cx, cy - s);
            ctx.bezierCurveTo(cx + s * 2, cy, cx, cy + s, cx, cy + s);
            ctx.bezierCurveTo(cx, cy + s, cx + s * 2, cy, cx, cy - s);
            ctx.bezierCurveTo(cx - s * 2, cy, cx, cy + s, cx, cy + s);
            ctx.closePath();
            if (filled) ctx.fill();
            else ctx.stroke();
        }

        function drawPolygon(ctx, cx, cy, sides, radius, filled) {
            const angle = (Math.PI * 2) / sides;
            ctx.beginPath();
            for (let i = 0; i < sides; i++) {
                const x = cx + radius * Math.cos(angle * i - Math.PI / 2);
                const y = cy + radius * Math.sin(angle * i - Math.PI / 2);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            if (filled) ctx.fill();
            else ctx.stroke();
        }

        function drawArrow(ctx, fromX, fromY, toX, toY) {
            const headLength = 10;
            const dx = toX - fromX;
            const dy = toY - fromY;
            const angle = Math.atan2(dy, dx);
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), toY - headLength * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), toY - headLength * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
        }

        function drawDiamond(ctx, cx, cy, width, filled) {
            ctx.beginPath();
            ctx.moveTo(cx, cy - width);
            ctx.lineTo(cx + width, cy);
            ctx.lineTo(cx, cy + width);
            ctx.lineTo(cx - width, cy);
            ctx.closePath();
            if (filled) ctx.fill();
            else ctx.stroke();
        }

        addTextBtn.addEventListener('click', () => {
            const text = textInput.value;
            if (!text) return;
            ctx.font = `${textSize.value}px sans-serif`;
            ctx.fillStyle = colorPicker.value;
            ctx.fillText(text, textX, textY);
            textInput.value = '';
        });

        document.querySelectorAll('#shapeControls button').forEach(btn => {
            btn.addEventListener('click', () => {
                shapeType = btn.dataset.shape;
            });
        });

        clearBtn.addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        downloadBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'mi_dibujo.png';
            link.href = canvas.toDataURL();
            link.click();
        });

        autofixBtn.addEventListener('click', () => {
            const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imgData.data;
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const gray = r * 0.299 + g * 0.587 + b * 0.114;
                data[i] = gray;
                data[i + 1] = gray;
                data[i + 2] = gray;
            }
            ctx.putImageData(imgData, 0, 0);
        });

        setActiveMode('pencil');
    </script>
</body>
</html>
```