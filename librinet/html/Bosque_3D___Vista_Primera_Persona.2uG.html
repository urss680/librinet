```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bosque 3D - Vista Primera Persona</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 16px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            z-index: 1000;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="info">
        Flechas: Moverse | Ratón: Girar cámara | Click: Bloquear ratón
    </div>
    <div id="crosshair"></div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Escena, cámara y renderizador
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x2c3e50, 20, 300);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.setClearColor(0x1a1a2e);
        document.body.appendChild(renderer.domElement);

        // Iluminación
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -150;
        directionalLight.shadow.camera.right = 150;
        directionalLight.shadow.camera.top = 150;
        directionalLight.shadow.camera.bottom = -150;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 300;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Suelo
        const groundGeometry = new THREE.PlaneGeometry(500, 500);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Crear árboles
        function createTree(x, z) {
            const tree = new THREE.Group();
            
            const trunkGeometry = new THREE.CylinderGeometry(0.8, 1.2, 8, 8);
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3c28 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 4;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);
            
            const leavesGroup = new THREE.Group();
            
            const leaves1Geometry = new THREE.ConeGeometry(6, 8, 8);
            const leaves1Material = new THREE.MeshLambertMaterial({ color: 0x1a4d1a });
            const leaves1 = new THREE.Mesh(leaves1Geometry, leaves1Material);
            leaves1.position.y = 10;
            leaves1.castShadow = true;
            leaves1.receiveShadow = true;
            leavesGroup.add(leaves1);
            
            const leaves2Geometry = new THREE.ConeGeometry(5, 7, 8);
            const leaves2Material = new THREE.MeshLambertMaterial({ color: 0x228B22 });
            const leaves2 = new THREE.Mesh(leaves2Geometry, leaves2Material);
            leaves2.position.y = 13;
            leaves2.castShadow = true;
            leavesGroup.add(leaves2);
            
            const leaves3Geometry = new THREE.ConeGeometry(4, 6, 8);
            const leaves3Material = new THREE.MeshLambertMaterial({ color: 0x32CD32 });
            const leaves3 = new THREE.Mesh(leaves3Geometry, leaves3Material);
            leaves3.position.y = 16;
            leaves3.castShadow = true;
            leavesGroup.add(leaves3);
            
            tree.add(leavesGroup);
            tree.position.set(x, 0, z);
            
            return tree;
        }

        // Agregar árboles
        for (let i = 0; i < 60; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 120;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            scene.add(createTree(x, z));
        }

        // Variables de control
        let mouseX = 0, mouseY = 0;
        let lat = 0, lon = 0;
        let phi = 0, theta = 0;
        let isPointerLocked = false;
        const playerPosition = new THREE.Vector3(0, 1.8, 0);

        // Solicitar bloqueo de puntero
        renderer.domElement.addEventListener('click', () => {
            renderer.domElement.requestPointerLock();
        });

        // Detectar cambio de estado del puntero
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
        });

        // Movimiento del ratón
        document.addEventListener('mousemove', (e) => {
            if (isPointerLocked) {
                lon -= e.movementX * 0.2;
                lat += e.movementY * 0.2;
                lat = Math.max(-85, Math.min(85, lat));
            }
        });

        // Control de teclas
        const keys = {};
        const moveSpeed = 0.4;

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Animación
        function animate() {
            requestAnimationFrame(animate);
            
            // Calcular rotación de la cámara
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);
            
            // Movimiento del jugador basado en la orientación de la cámara
            const forward = new THREE.Vector3(
                Math.sin(theta) * Math.cos(phi),
                0,
                Math.cos(theta) * Math.cos(phi)
            );
            const right = new THREE.Vector3(
                Math.cos(theta),
                0,
                -Math.sin(theta)
            );
            
            if (keys['ArrowUp']) {
                playerPosition.addScaledVector(forward, moveSpeed);
            }
            if (keys['ArrowDown']) {
                playerPosition.addScaledVector(forward, -moveSpeed);
            }
            if (keys['ArrowLeft']) {
                playerPosition.addScaledVector(right, moveSpeed);
            }
            if (keys['ArrowRight']) {
                playerPosition.addScaledVector(right, -moveSpeed);
            }
            
            // Actualizar posición de la cámara (SIEMPRE EN LA CABEZA DEL JUGADOR)
            camera.position.copy(playerPosition);
            
            // La cámara mira hacia donde está el ratón
            const lookDirection = new THREE.Vector3(
                Math.sin(theta) * Math.cos(phi),
                Math.sin(phi),
                Math.cos(theta) * Math.cos(phi)
            );
            camera.lookAt(camera.position.clone().add(lookDirection));
            
            renderer.render(scene, camera);
        }

        // Ajustar ventana
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
```