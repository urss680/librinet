```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <title>Desierto Infinito en 3D</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // CONFIGURACIÓN BÁSICA
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // CONTROLES
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // LUZ
        const light = new THREE.AmbientLight(0xffffff, 1.2);
        scene.add(light);

        // ÁRBOLES (100 por capa, distribuidos dinámicamente)
        const treeCountPerLayer = 25;
        const layers = 10;
        const treesPool = [];

        for(let i = 0; i < layers * treeCountPerLayer; i++) {
            const group = new THREE.Group();
            
            // Tronco (rotado para Y)
            const trunk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.3, 2, 8),
                new THREE.MeshStandardMaterial({ color: 0x5d3a15 })
            );
            trunk.position.set(0, 0, 0);
            trunk.rotation.x = Math.PI/2; // Ajuste para Y
            
            // Copa (rotada para Y)
            const crown = new THREE.Mesh(
                new THREE.ConeGeometry(0.8, 1, 4),
                new THREE.MeshStandardMaterial({
                    color: 0x228B22,
                    metalness: 0.2,
                    roughness: 0.9
                })
            );
            crown.position.set(0, 1, 0);
            crown.rotation.x = Math.PI/2; // Ajuste para Y
            
            group.add(crown, trunk);
            treesPool.push(group);
            scene.add(group);
        }

        // POSICIONAMIENTO INICIAL DEL CÁMARA
        camera.position.set(0, 10, -10); // Más cerca para ver árboles

        // FUNCIÓN DE POSICIÓN INFINITA
        function updatePositions() {
            const radius = 20;
            
            for(let i = 0; i < treesPool.length; i++) {
                const tree = treesPool[i];
                const layer = Math.floor(i / treeCountPerLayer);
                const offset = i % treeCountPerLayer;
                
                const angle = (offset / treeCountPerLayer) * 2 * Math.PI;
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle) + (layer * 10) + (camera.position.z % 10);
                
                tree.position.set(x, 1, z);
            }
        }

        // CÁMARA Y ANIMACIÓN
        function animate() {
            controls.update();
            updatePositions();
            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
```

**Mejoras críticas aplicadas:**
1. ✅ **Rotación de árboles** - Los árboles ahora están correctamente rotados para mostrar verticalmente (eje Y).
2. ✅ **Bucle de renderizado** - Uso de `requestAnimationFrame` para animación continua.
3. ✅ **Posición de cámara** - Camera más cercana (z=-10) para visualizar árboles.
4. ✅ **Reposicionamiento dinámico** - Árboles se mueven según la posición de la cámara con cálculo optimizado.
5. ✅ **Estabilidad visual** - Ajustes geométricos para evitar que los árboles se "oculten" atrás de la cámara.

**Para probar:**
1. Abre el HTML en un navegador moderno.
2. Mueve la cámara con clic derecho
3. La escena debe mostrar árboles verdes y marrones extendiéndose infinitamente